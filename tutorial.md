# Integrating with the Staking API

Welcome to the Staking API demo app tutorial. The goal is to get you up and running with our Staking API in 30 minutes or less!

We will build a basic single-page web app using Figment's Staking API. It will provide users with the ability to stake NEAR tokens with a single click. When it is running, the application looks like this:

![Demo App Screenshot](/public/img/demo-app-screenshot1.png)

For clarity, note that the terms "staking" and "delegating" are often used interchangeably.
In Proof of Stake blockchains, token holders delegate tokens to validator nodes to help secure the network. The tokens remain locked for a period of time and token holders are compensated with rewards for helping to secure the network.
If you're interested in learning more, check out the [Further Reading](#further-reading) section at the end of this tutorial.

The tutorial is structured to mimic the steps you would take to integrate the Staking API in your application. We have pre-built a simple NextJS app that's missing the Staking API functionality. As you follow along, you will need to complete the code in the relevant files to make the demo app work.
Each step of the tutorial will instruct you to fix certain lines of code or uncomment fetch requests.

## Flows

The Figment [Staking API](https://docs.figment.io/guides/staking-api/) breaks down the process of staking into steps we call **flows**. These flows provide a streamlined way to interact with a network to stake and unstake tokens from a user's account.

In this tutorial, we'll focus on staking [NEAR Protocol](https://near.org/) tokens and the process is similar for the other [supported protocols](https://docs.figment.io/api-reference). Each flow has multiple steps:

1. Initializing the flow by specifying the network (`near`), the chain code (`testnet`), the operation (`staking`) and the Staking API version number (`v1`)
2. Submitting details for the transaction, which returns a transaction object for the user to sign with their private key
3. Confirming the transaction details and signing the transaction
4. Broadcasting the signed transaction to the network
5. Confirming that the flow state has changed to `delegated`, meaning that the flow is complete and the delegated tokens are actively earning staking rewards

## Testnet account

We will first need to create a testnet account on NEAR so that we have some tokens to work with.

**Note**: You don't need a detailed understanding of the NEAR protocol to keep going. If you want to dive deeper later, here are some resources on the [NEAR account model](https://docs.near.org/concepts/basics/accounts/model) and [Access Keys](https://docs.near.org/concepts/basics/accounts/access-keys). This will help you understand how transaction signing works.

The relevant code is in `pages/api/createAccount.js`, which uses the [NEAR JavaScript API](https://docs.near.org/tools/near-api-js/quick-reference) to generate a random `ed25519` keypair. We store this keypair in the application state for convenience, backing it up to your browsers localStorage so you can pause during the tutorial and come back later without losing your keypair.

**Important**: Strictly speaking, private keys should _not_ be stored in a web browser, and any keypairs used on mainnet should be treated with extreme care. For this reason, we **strongly** recommend that you do not import any other keypairs for use in this demo app. The keypairs generated by this demo app are intended for use by the demo on testnet, and so long as they are only used within the context of this demo app, there is no real security concern. Remember: This is for learning purposes only.

This private key can be used to sign transaction payloads generated by the Staking API, simulating either an individual user or a custodian using the Staking API.

The function in `pages/api/createAccount.js` will create a randomly generated testnet address, which is automatically funded with 200 NEAR tokens. Each account has an account ID, a public key and a private key.

## Step 1: Get Started

Let's begin the process of completing the demo app code so that it functions properly! Once we have the staking functionality ready we'll enable the staking button.

If you haven't already, follow the steps in the repo's README to set up your app. By now your app should be running at http://localhost:3000.

Before moving further you'll need to click on "New Account" at the top right to initialise a new NEAR account.

We'll need a way to display the available and staked token balances.

In `pages/api/getNearBalance.js` we have set up a connection to the NEAR network to query the account balances using methods from `near-api-js`:

```js
export default async function (req, res) {
  if (!req.query.account) return res.status(406).send("missing account id");
  const client = await connect(nearConfig);
  const account = await client.account(req.query.account);
  const balance = await account.getAccountBalance();
  const staked = await account.getActiveDelegatedStakeBalance();
  return res.status(200).json({available, staked});
}
```

These values are then displayed on the client-side:

![Demo App Screenshot](/public/img/demo-app-screenshot2.png)

### Integrated, Delegated

If we clicked on the STAKE button at this point, we'll get an error. There is not staking functionality yet! Let's fix that by adding functionality to initialize a staking flow with the Staking API.

**Note**: Make sure you have setup your API key in `.env` as mentioned in the README.

Each flow has a unique flow ID. We need to store the flow ID so we can track it across its lifecycle and move it along.

When data is submitted to a flow, the Staking API will construct an unsigned transaction payload and return it in the response body. It is then up to the account holder to sign the transaction payload with the private key &mdash; in this case, the one generated by `createAccount.js`. Once the payload is signed, it can be submitted to the Staking API which will then broadcast the transaction to the network.

Once the transaction is confirmed, the delegation is active and the staked tokens will earn staking rewards.

## Step 3: Create a Flow

To get started, open the files `pages/index.js`, `components/AccountCard.js` and `pages/api/delegateFlow.js` in your code editor.

The input for the amount and the STAKE button are defined in `components/AccountCard.js`.

We need to call the Staking API with a valid Figment API key and the parameters needed to begin a new delegation flow.

In the file `pages/api/delegateFlow.js`, uncomment the fetch request on line 10 and save the file.

```js
  const response = await fetch(`https://near-slate.datahub.figment.io/api/v1/flows`, {
    method: "POST",
    headers: {
      Authorization: process.env.API_KEY,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      flow: {
        network_code: body.network_code,
        chain_code: body.chain_code,
        operation: body.operation,
        version: body.version,
      },
    }),
  });
```

- This fetch request is a POST containing the necessary headers and a JSON body, being sent to the Staking API endpoint for NEAR: `https://near-slate.datahub.figment.io/api/v1/flows`
- The JSON body must have the correct parameters. We define these in `pages/index.js`. Open `pages/index.js` and refer to the first fetch request inside the `delegate` function on line 48:

```js
// create the flow
response = await fetch("/api/delegateFlow", {
  headers: { "Content-Type": "application/json" },
  method: "POST",
  body: JSON.stringify({
    network_code: "near",
    chain_code: "testnet",
    operation: "staking",
    version: "v1",
  }),
});
```

Notice the values we're passing in the body of the request include the `network_code`, in this case `near`, along with `testnet` for `chain_code`, `staking` as the `operation` we want to execute, and `v1` as the API version.

- This POST request is going to be processed by `pages/api/delegateFlow.js` to initialize a new flow.
- The response to this request will contain the details of the initialized flow, including the flow's `id`, `state`, and the `actions` which can be performed at this stage of the flow. For more, check out the specification on the [Figment Docs](https://docs.figment.io/guides/staking-api/near/delegate/create-new-flow).

## Step 4: Creating a Delegation Transaction

Now that we have the ability to initialize a flow, we can add functionality to advance the flow toward a delegation.

In `pages/index.js` we'll perform another request to continue the flow with the correct inputs.
Keep in mind that when continuing with a flow, we need to use a PUT request since we're updating an existing resource.

In the file `pages/api/submitData.js`, uncomment the fetch request on line 8 and save the file.

```js
  const response = await fetch(`https://near-slate.datahub.figment.io/api/v1/flows/${flow_id}/next`, {
    method: "PUT",
    headers: {
      Authorization: process.env.API_KEY,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });
```

Before we do anything else, we need to submit the data to the Staking API and get the `name` for the next action.

Going back to the `delegate` function in `pages/index.js`, we'll need to pass a request body to `pages/api/submitData` that includes the `flow_id` and the `name` of the action we are performing. We also need the required `inputs[]` which can be found in the `actions[0]` object, obtained from the `pages/api/createFlow` [response](https://docs.figment.io/guides/staking-api/near/delegate/create-new-flow/#response).

Open `pages/index.js` and you'll see the fetch request to submit data starting in line 76:

```js
response = await fetch("/api/submitData", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    flow_id,
    name: name,
    inputs: {
      delegator_address: appState.accountId,
      delegator_pubkey: appState.publicKey,
      validator_address: validator_address,
      amount,
      max_gas: null,
    },
  }),
});
```

We're getting the properties we need from the response we received after initializing the flow. In line 67 of `pages/index.js`, we're assigning the `flow_id` variable to track our flow ID and we're assigning the `actions` variable. `actions` is a list that includes the action we need, `create_delegate_tx`, as the first item in the list. We assign the variable `name` to this action in line 71.

We also include the inputs `delegator_address` and `delegator_pubkey` from our account, along with `validator_address`, `amount` and an optional `max_gas` amount. The `amount` comes from the user form, which is submitted when a user clicks the STAKE button.

## Step 5: Signing the Transaction

After the app submits the delegation data, the Staking API will respond with an unsigned transaction payload.
The unsigned transaction payload appears in two locations in the response:

- In the `actions`, under the `inputs[]` array of the action `sign_delegate_tx` as `transaction_payload`, and
- In the `data` object, as the `raw` property of the `delegate_transaction` object

**Note**: The `signing_payload` is only used when signing with a custodial solution such as the Fireblocks API. There is more information linked in the [Further Reading](#further-reading) section at the end of this tutorial.

To get the unsigned transaction payload from the `raw` property of `delegate_transaction`, locate this code on line 98 of `pages/index.js`. Uncomment it by removing `//` from the beginning of the line and save the file.

```js
const transaction_payload = json.data.delegate_transaction.raw;
```

The payload is then passed to the `sign` method of the [npm package @figmentio/slate](https://www.npmjs.com/package/@figmentio/slate), which abstracts the implementation details of signing payloads for networks supported by the Staking API. You could also use a network-specific client library for signatures, such as `near-api-js`, which is precisely what the `@figmentio/slate` npm package is doing.

We're leveraging the `sign` method on line 103 of `pages/index.js`. It takes four parameters: The `network` the flow was created on, the API `version` used to create the flow, the unsigned `transaction_payload`, and an array of private keys used to sign the transaction:

```js
const signed_payload = await slate.sign("near", "v1", transaction_payload, [secretKey]);
```

## Step 6: Staking API Webhooks

When a user clicks STAKE, it begins the delegation process. The button is disabled for the moment, we'll get around to enabling it in the next step.

Using webhooks, we can get a notification when the state of the flow becomes "delegated". This lets us create a smooth UX where the button displays a loading state until the flow is complete and the delegation is active.

We use a server-side event with the webhook subscription, using the [EventSource API](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) to update the client.

First, we need a way to listen for incoming webhook payloads from the Staking API. The secure tunnel URL has been automatically inserted into `.env`, so there's no action required here. Check out `./start-dev.js` to see where we are running both processes when starting the server.

The webhook functionality is defined in three places:

1. In `index.js`, inside of the `delegate` function, we instantiate the EventSource, open the connection, then parse incoming message data.

When the incoming message contains the `delegated` state that we're looking for, it will update the balances and then close the EventSource connection.

```js
    const eventSource = new EventSource("/api/webhook");
    eventSource.onopen = () => { console.log("opened"); };
    eventSource.onmessage = (msg) => {
      const { state } = JSON.parse(msg.data)
      if (state === 'delegated') {
        updateBalances()
        setDelegating(false)
        eventSource.close()
      }
    };
```

2. In `pages/api/webhook.js`, the `subscribe` function calls the Staking API Webhooks endpoint with the `target_url`, `event_types` and sets `enabled` true. `${process.env.ORIGIN}` refers to the tunneled URL as it has been placed into `.env`.

```js
    body: JSON.stringify({
      target_url: `${process.env.ORIGIN}/api/webhook-callback`,
      event_types: ["*"],
      enabled: true,
    })
```

In `pages/api/webhook.js`, the `handler` subscribes to the webhook. It then caches the webhook ID and a function used to resolve the status of the webhook. The ID is needed so that we can unsubscribe from the webhook.

```js
  cache.put('webhookId', id)
  cache.put('resolve', function () {
    res.write(`data: { "state": "delegated", "id": ${id} }\n\n`);
    res.end('done\n');
```

3. In `pages/api/webhook-callback.js`, the `handler` function gets the cached values, unsubscribes from the webhook as it is no longer needed. It then calls the cached `resolve` function, completing the cycle.

```js
async function handler(req, res) {
    const webhookId = cache.get('webhookId')
    const resolve = cache.get('resolve')
    console.log(await unsubscibe(webhookId))
    resolve()
    return res.json({ ok: true })
}
```

The state is set to `delegated`; the `eventSource.onmessage` in `index.js` is satisfied; the balances are updated and the `eventSource` is closed.

## Step 7: Broadcasting the Transaction

We have set up a webhook so that we get notified when the Staking API completes the delegation.

The signed transaction payload must now be sent to the Staking API to be broadcast to the network.

To send the signed payload, we need to perform another request. The request body should contain the `name` of the action we're performing (in this case `sign_delegate_tx`) and the `inputs` (an object with the property `transaction_payload` with a value that is the signed payload).

In `pages/api/broadcastTx.js` uncomment the fetch request starting in line 8 and save the file.

```js
  const response = await fetch(`https://near-slate.datahub.figment.io/api/v1/flows/${flow_id}/next`, {
    method: 'PUT',
    headers: {
      "Authorization": process.env.API_KEY,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      "name": "sign_delegate_tx",
      "inputs": {
        "transaction_payload": signed_payload
      }
    })
  });
```

When the signed payload has been broadcast to the network, the flow state will change to `delegate_tx_broadcast`.
While the flow is in this state, the transaction is awaiting confirmation by the network.

The webhook callback will be triggered when the state changes to `delegated`, meaning we can update the balances on the client-side to confirm that we now have a staked balance.

### Ensure the STAKE button is enabled

The final thing to do to enable the STAKE button is setting the `disabled` boolean on line 43 of `components/AccountCard.js` to the value below it, by commenting out line 43 and uncommenting line 44:

```js
  // Leave this set to true until instructed to change it in Step 7
  // const disabled = true;
  const disabled = waiting || delegating
```

The reason we kept the STAKE button disabled until now is because unless the server-side code is functional, the button would remain in a loading state. We don't want to be chasing down errors that distract from the task at hand!

We're now ready to test our app. Let's stake 10 NEAR tokens by filling in the input on the app and clicking STAKE. It takes about 10-30 seconds to process and... voila! You added staking functionality to the demo app.

## Tutorial Complete

That's it! Congratulations, you've successfully completed the code to integrate the Figment Staking API into an application.

## Further Reading

As you dive deeper, here are some links to the Figment Docs you may find useful:

- Read more about [Staking with Figment](https://www.figment.io/staking-with-figment)
- Learn about the [Staking API endpoints](https://docs.figment.io/guides/staking-api/staking-api-endpoints) & other Staking API operations in the guide [Working With Staking API Flows](https://docs.figment.io/guides/staking-api/working-with-staking-api-flows)
- Read about [Staking API Webhooks](https://docs.figment.io/guides/staking-api/staking-api-endpoints#managing-webhooks) if you need to set up notifications
- Learn more about [Signing Transactions with Figment's npm package](https://docs.figment.io/guides/staking-api/figment-signing-transactions) and [Signing Transactions with the Fireblocks API](https://docs.figment.io/guides/staking-api/fireblocks-signing-transactions)
- Read more about NEAR's [gas fees](https://docs.near.org/concepts/basics/transactions/gas) for transactions
- Learn more about checking flow state manually in the [Figment Docs](https://docs.figment.io/api-reference/staking-api/near#get%20flow%20status)