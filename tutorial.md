# Integrating with the Staking API

## Flows

The Figment Staking API works with the concept of a flow, a specific set of actions to be completed. More information is available in the [Staking API Overview](https://docs.figment.io/guides/staking-api/) On the Figment Docs.

In this tutorial, we'll focus on the delegation or "staking" flow.

This Staking API flow has multiple steps, which include:

1. Initializing the flow by specifying the network (`near`), the chain code (`testnet`), the operation (`staking`) and the Staking API version number (`v1`)
2. Creating a transaction payload which needs to be signed. This will include details like the address from which tokens will be staked and its public key, the validator address to delegate tokens to, and an amount of tokens to delegate
3. Confirming the transaction details and signing the transaction payload
4. Broadcasting the signed transaction to the network
5. Confirming that the flow state has changed to `delegated`, indicating that the flow is complete and the delegated tokens are actively earning staking rewards

## Testnet account

To demonstrate the staking API and delegating tokens, we will first need to create a testnet account on NEAR so that we have some tokens.

If you're curious, read more about the [NEAR account model](https://docs.near.org/concepts/basics/accounts/model) and [Access Keys](https://docs.near.org/concepts/basics/accounts/access-keys) to understand how keypairs function on NEAR. You don't need to dive into this topic to understand the Staking API, but it is useful to know how transaction signing works.

The relevant code is in the file `pages/api/createAccount.js`, which uses the [NEAR JavaScript API](https://docs.near.org/tools/near-api-js/quick-reference) to generate a random `ed25519` Keypair. It just works and we store the keypair in the application state for convenience, backing it up to your browsers localStorage so you can pause during the tutorial and come back later if necessary (without losing your keypair).

- Note: `ed25519` refers to the type of [Elliptic Curve Digital Signature Algorithm](https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages) that the keypair is using. This is also explicitly referenced by the prefix `ed25519:` before the public and private keys.

This private key is used to sign the transaction payloads generated by the Staking API, simulating either an individual user or a custodian using the Staking API.

TLDR; `pages/api/createAccount.js` will provide you with a randomly generated .testnet address, which is automatically provided with a balance of 200 NEAR tokens upon creation. The account is comprised of an account ID and a keypair: A public key and a private key.

**Important**: Strictly speaking, private keys should _not_ be stored in a web browser, and any keypairs used on mainnet should be treated with extreme care. For this reason, we **strongly** recommend that you do not import any other keypairs for use in this demo app.

The keypairs generated by this demo app are intended for use on the testnet, and so long as they are only used within the context of this demo app, there is no real security concern. Remember: This is for learning purposes only. In production, you will absolutely want to handle signing offline and preferably using an encrypted secrets vault such as Hashicorp's [Vault Project](https://www.vaultproject.io/).

## Client-side and Server-side

Code in the `/pages` directory is being run on the client-side, in the web browser.

Code in the `/pages/api` directory is being run on the server-side, _not_ in the web browser.

## Integrated, Delegated

Armed with a Figment API key to access the Staking API and a NEAR testnet account with tokens, the first step is to initialize a new staking flow.

Any time a flow is initialized, we are provided with a unique flow ID. It is important to store the flow ID, at least until the flow has been completed. Without the flow ID, we can't continue the flow!

When data is submitted to a flow, the Staking API will construct an unsigned transaction payload and provide it to us in the response body. It is then up to the account holder (in this case, us!) to sign the transaction, which authorizes the transfer of tokens out of the delegator's account to the validator address.

We will sign the payload using the private key of the testnet keypair we have generated. Once the payload is signed, it can be submitted to the Staking API which will then broadcast the transaction to the network.

Once the transaction is confirmed, the delegation is active and the staked tokens will be earning staking rewards over time.

Let's begin the process of completing the demo app code so that it functions properly!

## Step 1: Create a Flow

To get started, open the files `pages/index.js` and `pages/api/delegateFlow.js` in your code editor.

- In the file `pages/index.js` you will find all of the code for the frontend. This is where we will define the functions we need to complete each step of the flow.

- In the file `pages/api/delegateFlow.js` you will find the code to connect to the Staking API and initialize new flows. You will need to complete the code in this file by uncommenting the fetch request and saving the file to continue to the next step of the tutorial.

On the index page, we've provided a number input and a "click to stake" button. When the user wants to stake, they can input a number of tokens and click the button to initiate the staking process.

Since you've checked out the `tutorial` branch of this repository, the "click to stake" button &mdash; which is defined in the return value of the `Home` function in `pages/index.js` &mdash; won't work right away.

When this button is clicked, we'll need to perform an asynchronous fetch call to the Staking API, passing a valid Figment API key and the parameters needed to begin a new Delegation flow.

In the file `pages/api/delegateFlow.js`, locate the code snippet:

```js
/**
 * 
 * 
  const response = await fetch(`https://near-slate.datahub.figment.io/api/v1/flows`, {
    method: "POST",
    headers: {
      Authorization: process.env.API_KEY,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      flow: {
        network_code: body.network_code,
        chain_code: body.chain_code,
        operation: body.operation,
        version: body.version,
      },
    }),
  });
*/
```

- The fetch request is a POST request containing the necessary headers and a JSON body, being sent to the Staking API endpoint for NEAR: `https://near-slate.datahub.figment.io/api/v1/flows`
- The JSON body must have the correct parameters. Read more about them in the Figment Docs [here](https://docs.figment.io/guides/staking-api/near/delegate/create-new-flow)

Uncomment this block of code in `pages/api/delagateFlow.js` then save the file.

In the file `pages/index.js`, refer to the first fetch request inside the `delegate` function:

```js
    response = await fetch("/api/delegateFlow", {
      headers: { "Content-Type": "application/json" },
      method: "POST",
      body: JSON.stringify({
        network_code: "cosmos",
        chain_code: "testnet",
        operation: "staking",
        version: "v1"
      })
    });
```

Somebody accidentally set the `network_code` to `cosmos`! You'll need to change it to `near` so the correct flow is initialized.

- This POST request is going to be processed by `delegateFlow.js`, passing the parameters `network_code`, `chain_code`, `operation` and `version` to initialize a new flow.

- Provided that you have a valid API key in your `.env` file to access the Staking API, the response to this fetch request will contain the details of the initialized flow which includes the flow `id`, the flow `state`, and the `actions` which can be performed at this stage of the flow.

Read more about the specification on the Figment Docs [here](https://docs.figment.io/guides/staking-api/near/delegate/create-new-flow).

In the file `pages/api/getNearBalance.js` we'll query the account's available balance and staked balance using methods from `near-api-js` so that we can display them on the client-side:

```js
import { connect } from 'near-api-js';
import nearConfig from '../../utilities/nearConfig';

export default async function (req, res) {
    if (!req.query.account) return res.status(406).send('missing account id');
    const client = await connect(nearConfig);
    const account = await client.account(req.query.account);
    let balance = await account.getAccountBalance();
    const stake = await account.getActiveDelegatedStakeBalance();
    balance = { ...balance, ...stake }
    return res.status(200).json(balance);
}
```

## Step 2: Creating a Delegation Transaction

In the file `pages/api/submitData.js` we'll perform another fetch request to the Staking API with the inputs coming from the client-side. Keep in mind that when continuing with a flow, we need to use a PUT request, not a POST request.

```js
/**
 * 
 * 
    const response = await fetch(`https://near-slate.datahub.figment.io/api/v1/flows/${flow_id}/next`, {
      method: "PUT",
      headers: {
        Authorization: process.env.API_KEY,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    });
*/
```

Still working within the `delegate` function in `pages/index.js`, we can see which `inputs` are required from the [Staking API response](https://docs.figment.io/guides/staking-api/near/delegate/create-new-flow#sample-response). We'll use these to create our client-side fetch request:

```js
    response = await fetch("/api/submitData", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        flow_id,
        name: actions[0].name,
        inputs: {
          delegator_address: appState.accountId,
          delegator_pubkey: appState.publicKey,
          validator_address: validator_address,
          amount: Number.parseFloat(stakeAmount),
        }
      })
    })
```

- Keep using the same `flow_id` until the flow is completed
- The `name` field is the name of the action we're taking &mdash; `create_delegate_tx`
- The `inputs` are: `delegator_address`, `delegator_pubkey`, `validator_address`, and `amount`
- There is also an optional `max_gas` parameter which we have intentionally left out. You can try adding it in if you want!

## Step 3: Signing the Transaction

The unsigned transaction payload is returned in the response from the Staking API once you have submitted the delegation data. It is good practice to decode the payload to make sure you're signing the correct transaction. Don't blindly sign payloads.

The unsigned transaction payload appears in two locations in the response:

- In the `actions`, under the `inputs` array of the action `sign_delegate_tx` as `transaction_payload`
- Also in the `data` object, as the `raw` property of the `delegate_transaction` object.

Note that the `signing_payload` is only used when perfoming the signing with a custodial solution such as Fireblocks. Refer to our guide on [Signing Transactions with the Fireblocks API](https://docs.figment.io/guides/staking-api/fireblocks-signing-transactions) for more information.

In this example, we're getting the unsigned payload from the `raw` property:

```js
/**
 * 
 * 
const transaction_payload = json.data.delegate_transaction.raw;
*/
```

The payload can be signed using the npm package `@figmentio/slate`, which abstracts some of the cumbersome details of the signing process when using specific client libraries like `near-api-js`.

The `sign` method takes four parameters and, when necessary, an options object as a fifth parameter. NEAR does not require any extra options, so we're not passing any here. Networks like Cosmos and Polkadot require extra options to be passed when signing payloads, this may be covered in a future version of this tutorial.

The transaction payload signing is happening in the `delegate` function inside of `pages/index.js`:

```js
/**
 * 
 * 
const signed_payload = await slate.sign("near", "v1", transaction_payload, [secretKey]);
*/
```

## Step 4: Broadcasting the Transaction

The signed transaction payload must now be broadcast to the network by the Staking API.

To send the signed payload, we'll perform another fetch request and pass the `name` of the action we're performing and the `inputs`, which will include the `transaction_payload`. Uncomment the fetch request in `pages/api/broadcastTx.js:

```js
/**
 * 
 * 
    const response = await fetch(`https://near-slate.datahub.figment.io/api/v1/flows/${flow_id}/next`, {
      method: 'PUT',
      headers: {
        "Authorization": process.env.API_KEY,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        "name": "sign_delegate_tx",
        "inputs": {
          "transaction_payload": signed_payload
        }
      })
    });
*/
```

When the signed payload has been broadcast to the network, the flow state will update to `delegate_tx_broadcast`. While the flow is in this state, the transaction is awaiting confirmation on the blockchain.

## Step 5: Flow State

Since the transaction will not take long to confirm, we can check the flow state manually by polling every 2.5 seconds with `setTimeout`. We want to know when the flow state becomes `delegated` and then update our available balance and staked balance:

```js
/**
 * 
 * 
  async function monitorTx() {
    const response = await fetch(`/api/getFlowState?flow_id=${pendingTx}`);
    if (!response.ok) alert('yo');
    const json = await response.json();
    if (json.state === 'delegated') {
      setPendingTx(null);
      updateBalances();
    } else {
      setTimeout(monitorTx, 2500);
    }
  }
*/
```

For more complex implementations, we might want to create a webhook to send a notification when the state changes from `delegate_tx_broadcasting` to `delegated`. This method is slightly more complex and requires us to verify the webhook payloads, so we won't cover it in this tutorial.

## Tutorial Complete

Congratulations, you've successfully completed the code to integrate the Figment Staking API into a full stack application!

You can now run the demo app by starting the Next.js Development Server with the terminal command `npm run dev` and visiting `https://localhost:3000` in your web browser.

Everything should function the same as it does on the `main` branch of the repository.

Since you've cloned the repo to your local machine, feel free to experiment further. We hope you enjoyed this tutorial, and we can't wait to see how you integrate Figment APIs into your use case.

## Further Reading

Here are some links to the Figment Docs you may find useful:

- Learn about other Staking API operations and networks in the guide [Working With Staking API Flows](https://docs.figment.io/guides/staking-api/working-with-staking-api-flows)
- Read about the [Staking API endpoints](https://docs.figment.io/guides/staking-api/staking-api-endpoints)
- Read about [Staking API Webhooks](https://docs.figment.io/guides/staking-api/staking-api-endpoints#managing-webhooks) if you need to set up notifications
- Learn about [Signing Transactions with Figment's npm package](https://docs.figment.io/guides/staking-api/figment-signing-transactions) and [Signing Transactions with the Fireblocks API](https://docs.figment.io/guides/staking-api/fireblocks-signing-transactions)
