# Integrating with the Staking API

## Flows

The Figment Staking API works with the concept of a flow, a specific set of actions to be completed. More information is available in the [Staking API Overview](https://docs.figment.io/guides/staking-api/) On the Figment Docs.

In this tutorial, we'll focus on the delegation or "staking" flow.

This Staking API flow has multiple steps, which include:

1. Initializing the flow by specifying the network (`near`), the chain code (`testnet`), the operation (`staking`) and the Staking API version number (`v1`)
2. Creating a transaction payload which needs to be signed. This will include details like the address from which tokens will be staked and its public key, the validator address to delegate tokens to, and an amount of tokens to delegate
3. Confirming the transaction details and signing the transaction payload
4. Broadcasting the signed transaction to the network
5. Confirming that the flow state has changed to `delegated`, indicating that the flow is complete and the delegated tokens are actively earning staking rewards

## Testnet account

To demonstrate the staking API and delegating tokens, we will first need to create a testnet account on NEAR so that we have some tokens.

If you're curious, read more about the [NEAR account model](https://docs.near.org/concepts/basics/accounts/model) and [Access Keys](https://docs.near.org/concepts/basics/accounts/access-keys) to understand how keypairs function on NEAR. You don't need to dive into this topic to understand the Staking API, but it is useful to know how transaction signing works.

The relevant code is in the file `pages/api/createAccount.js`, which uses the [NEAR JavaScript API](https://docs.near.org/tools/near-api-js/quick-reference) to generate a random `ed25519` Keypair. It just works and we store the keypair in the application state for convenience, backing it up to your browsers localStorage so you can pause during the tutorial and come back later if necessary (without losing your keypair).

- Note: `ed25519` refers to the type of [Elliptic Curve Digital Signature Algorithm](https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages) that the keypair is using. This is also explicitly referenced by the prefix `ed25519:` before the public and private keys.

This private key is used to sign the transaction payloads generated by the Staking API, simulating either an individual user or a custodian using the Staking API.

TLDR; `pages/api/createAccount.js` will provide you with a randomly generated .testnet address, which is automatically provided with a balance of 200 NEAR tokens upon creation. The account is comprised of an account ID and a keypair: A public key and a private key.

**Important**: Strictly speaking, private keys should _not_ be stored in a web browser, and any keypairs used on mainnet should be treated with extreme care. For this reason, we **strongly** recommend that you do not import any other keypairs for use in this demo app.

The keypairs generated by this demo app are intended for use on the testnet, and so long as they are only used within the context of this demo app, there is no real security concern. Remember: This is for learning purposes only. In production, you will absolutely want to handle signing offline and preferably using an encrypted secrets vault such as Hashicorp's [Vault Project](https://www.vaultproject.io/).

## Client-side and Server-side

Code in the `/pages` directory is being run on the client-side, in the web browser.

Code in the `/pages/api` directory is being run on the server-side, _not_ in the web browser.

## Integrated, Delegated

Armed with a Figment API key to access the Staking API and a NEAR testnet account with tokens, the first step is to initialize a new staking flow.

Any time a flow is initialized, we are provided with a unique flow ID. It is important to store the flow ID, at least until the flow has been completed. Without the flow ID, we can't continue the flow!

When data is submitted to a flow, the Staking API will construct an unsigned transaction payload and provide it to us in the response body. It is then up to the account holder (in this case, us!) to sign the transaction, which authorizes the transfer of tokens out of the delegator's account to the validator address.

We will sign the payload using the private key of the testnet keypair we have generated. Once the payload is signed, it can be submitted to the Staking API which will then broadcast the transaction to the network.

Once the transaction is confirmed, the delegation is active and the staked tokens will be earning staking rewards over time.

Let's begin the process of completing the demo app code so that it functions properly!

## Step 1: Create a Flow

To get started, open the files `pages/index.js` and `pages/api/delegateFlow.js` in your code editor.

- In the file `pages/index.js` you will find all of the code for the frontend. This is where we will define the functions we need to complete each step of the flow.

- In the file `pages/api/delegateFlow.js` you will find the code to connect to the Staking API and initialize new flows. You will need to complete the code in this file by uncommenting the fetch request and saving the file to continue to the next step of the tutorial.

On the index page, we've provided a number input and a "click to stake" button. When the user wants to stake, they can input a number of tokens and click the button to initiate the staking process.

Since you've checked out the `tutorial` branch of this repository, the "click to stake" button &mdash; which is defined in the return value of the `Home` function in `pages/index.js` &mdash; won't work right away.

When this button is clicked, we'll need to perform an asynchronous fetch call to the Staking API, passing a valid Figment API key and the parameters needed to begin a new Delegation flow.

In the file `pages/api/delegateFlow.js`, locate the fetch request:

```js
/**
  const response = await fetch(`https://near-slate.datahub.figment.io/api/v1/flows`, {
    method: "POST",
    headers: {
      Authorization: process.env.API_KEY,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      flow: {
        network_code: body.network_code,
        chain_code: body.chain_code,
        operation: body.operation,
        version: body.version,
      },
    }),
  });
*/
```

- The fetch request is a POST request containing the necessary headers and a JSON body, being sent to the Staking API endpoint for NEAR: `https://near-slate.datahub.figment.io/api/v1/flows`
- The JSON body must have the correct parameters. Read more about them in the Figment Docs [here](https://docs.figment.io/guides/staking-api/near/delegate/create-new-flow)

Uncomment this block of code in `pages/api/delagateFlow.js` (remove lines 8 and 24), then save the file.

In the file `pages/index.js`, refer to the first fetch request inside the `delegate` function:

```js
    response = await fetch("/api/delegateFlow", {
      headers: { "Content-Type": "application/json" },
      method: "POST",
      body: JSON.stringify({
        network_code: "cosmos",
        chain_code: "testnet",
        operation: "staking",
        version: "v1"
      })
    });
```

Somebody accidentally set the `network_code` here to `cosmos`! You'll need to change it to `near` so the flow is initialized for the correct network.

- This POST request is going to be processed by `delegateFlow.js`, passing the parameters `network_code`, `chain_code`, `operation` and `version` to initialize a new flow.

- Provided that you have a valid API key in your `.env` file to access the Staking API, the response to this fetch request will contain the details of the initialized flow. This includes the flow `id`, the flow `state`, and the `actions` which can be performed in this part of the flow.

Read more about the specification on the Figment Docs [here](https://docs.figment.io/guides/staking-api/near/delegate/create-new-flow).

### Balances

In the file `pages/api/getNearBalance.js` we'll query the account's available balance and staked balance using methods from `near-api-js`, so that we can display them on the client-side:

```js
export default async function (req, res) {
    if (!req.query.account) return res.status(406).send('missing account id');
    const client = await connect(nearConfig);
    const account = await client.account(req.query.account);
    const balance = await account.getAccountBalance();
    const staked = await account.getActiveDelegatedStakeBalance();
    return res.status(200).json({ 
        available: undefined,
        staked: undefined 
    });
}
```

Oops! Somebody left the return values as `undefined`. We'd better fix this by returning a parsed floating point integer.

Replace the `undefined` values on lines 11 and 12 with the following code, then save the file:

```js
      available: Number.parseFloat(balance.total || 0),
      staked: Number.parseFloat(staked.total || 0) 
```

- `getAccountBalance` and `getActiveDelegatedStakeBalance` return balances formatted as BigNumber, which is why they need to be parsed before being displayed on the client-side. The utility functions in `near-api-js` also include methods to parse and format amounts.

## Step 2: Creating a Delegation Transaction

In the file `pages/api/submitData.js` we'll perform another fetch request to the Staking API with the inputs coming from the client-side. Keep in mind that continuing a flow with the `/next` endpoint uses a PUT request, not a POST request.

```js
/**
    const response = await fetch(`https://near-slate.datahub.figment.io/api/v1/flows/${flow_id}/next`, {
      method: "PUT",
      headers: {
        Authorization: process.env.API_KEY,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    });
*/
```

Still working within the `delegate` function in `pages/index.js`. We can see which `inputs` we need to submit in the [Staking API response](https://docs.figment.io/guides/staking-api/near/delegate/create-new-flow#sample-response). We'll use these to create our client-side fetch request:

```js
    response = await fetch("/api/submitData", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        flow_id,
        name: actions[0].name,
        inputs: {
          delegator_address: appState.accountId,
          delegator_pubkey: appState.publicKey,
          validator_address: validator_address,
          amount: Number.parseFloat(stakeAmount),
        }
      })
    })
```

- Keep using the same `flow_id` until the flow is completed
- The `name` field is the name of the action we're taking &mdash; `create_delegate_tx`
- The `inputs` are: `delegator_address`, `delegator_pubkey`, `validator_address`, and `amount`
- There is also an optional `max_gas` parameter which we've omitted. You can try adding it in, if you want! Check the [parameters](https://docs.figment.io/guides/staking-api/near/delegate/submit-delegate-data#parameters) on the Figment Docs for more information.

## Step 3: Signing the Transaction

Once you have submitted the delegation data, the unsigned transaction payload is returned in the response from the Staking API. It is good practice to decode the payload with `@figmentio/slate` and cross check with your inputs to make sure you're signing the correct transaction. Feel free to add this improvement later, but for now let's focus on signing the payload:

The unsigned transaction payload appears in two locations in the response:

- In the `actions`, under the `inputs` array of the action `sign_delegate_tx` as `transaction_payload`
- Also in the `data` object, as the `raw` property of the `delegate_transaction` object

**Note**: The `signing_payload` is a hashed representation of the transaction payload and is only used when signing with a custodial solution such as the Fireblocks API.

In this example, we're getting the unsigned transaction payload from the `raw` property. Locate this commented code on line 69 of `pages/index.js`, uncomment it and save the file:

```js
// const transaction_payload = json.data.delegate_transaction.raw;
```

The payload is then passed to the `sign` method of the npm package `@figmentio/slate`, which abstracts some of the signing process for networks supported by the Staking API. You might also use a network-specific client library for signatures, such as `near-api-js` - but under the hood this is precisely what the slate package is doing. Keep it DRY!

The `sign` method takes four parameters: The `network`, the API `version`, the unsigned transaction payload, and an array of private keys used to sign the transaction.

When necessary, an options object can be passed as a fifth parameter. NEAR does not require any extra options for signing, so we're not passing it as a parameter here. Networks such as Cosmos and Polkadot require options to be passed when signing.

## Step 4: Broadcasting the Transaction

Finally, the signed transaction payload can be broadcast to the network by the Staking API.

To send the signed payload, we'll perform another fetch request and pass the `name` of the action we're performing (`sign_delegate_tx`) and the `inputs`, which must include the `transaction_payload`. 

Uncomment the fetch request in `pages/api/broadcastTx.js` (remove lines 8 and 22) then save the file:

```js
/**
    const response = await fetch(`https://near-slate.datahub.figment.io/api/v1/flows/${flow_id}/next`, {
      method: 'PUT',
      headers: {
        "Authorization": process.env.API_KEY,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        "name": "sign_delegate_tx",
        "inputs": {
          "transaction_payload": signed_payload
        }
      })
    });
*/
```

When the signed payload has been broadcast to the network, the Staking API's response will indicate the new flow state `delegate_tx_broadcast`. While the flow is in this state, the transaction has been broadcast to the network and is awaiting confirmation on the blockchain.

## Step 5: Flow State

Since the transaction will not take long to confirm, we can check the flow state manually. We simply want to know when the flow state becomes `delegated`, then update our available balance and staked balance on the client-side. We can perform a GET request to the Staking API endpoint to get the curent status of the flow, using its flow ID.

In the file `pages/api/getFlowState.js`, uncomment the fetch request (remove lines 7 and 14) then save the file:

```js
/**
    const response = await fetch(`https://near-slate.datahub.figment.io/api/v1/flows/${flow_id}`, {
        method: "GET",
        headers: {
            Authorization: process.env.API_KEY,
        }
    });
*/
```

Also, in `pages/index.js`, locate the `waitForDelegation` function, uncomment the fetch request on line 122 and save the file:

```js
    // const result = await fetch(`/api/getFlowState?flow_id=${transaction}`);
```

**Note**: For more complex implementations, we might create a webhook to send a notification when the state changes from `delegate_tx_broadcasting` to `delegated`. This method is slightly more complex and requires us to verify the webhook payloads, so we won't cover it in this tutorial.

## Tutorial Complete

Congratulations, you've successfully completed the code to integrate the Figment Staking API into a full stack application!

You can now run the demo app by starting the Next.js Development Server with the terminal command `npm run dev` and visiting `https://localhost:3000` in your web browser. Try creating an account, and staking some of your testnet NEAR tokens in real time with a single click!

If you have not already, please take some time to review the code in `pages/api` and `pages/index.js` to understand the interactions between client-side and server-side. Since you've cloned this repository to your local machine, feel free to experiment further.

We hope you enjoyed this tutorial, and we can't wait to see how you integrate Figment APIs into your use case!

## Further Reading

Here are some links to the Figment Docs you may find useful:

- Learn about other Staking API operations and networks in the guide [Working With Staking API Flows](https://docs.figment.io/guides/staking-api/working-with-staking-api-flows)
- Read about the [Staking API endpoints](https://docs.figment.io/guides/staking-api/staking-api-endpoints)
- Read about [Staking API Webhooks](https://docs.figment.io/guides/staking-api/staking-api-endpoints#managing-webhooks) if you need to set up notifications
- Learn about [Signing Transactions with Figment's npm package](https://docs.figment.io/guides/staking-api/figment-signing-transactions) and [Signing Transactions with the Fireblocks API](https://docs.figment.io/guides/staking-api/fireblocks-signing-transactions)
